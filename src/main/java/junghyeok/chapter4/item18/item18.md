# 상속보다는 컴포지션을 사용하라

이 장에서 상속은 하위클래스가 다른클래스를 확장하는 의미를 갖는다. (인터페이스 Implements가 아님)

## 상속의 단점

+ 캡슐화를 깨뜨린다.
   + 상위클래스의 구현의 변화가 생기면 하위클래스에 영향을 미친다.
   + 상위클래스의 메서드를 재정의할 수도 있지만, 이 방식은 어렵고, 시간도 더들고, 성능문제도 생길수있다.
     + 위의 두문제는, 상위클래스의 메서드를 재정의하는데서 오는문제이다.
   + 그래서, 상속은해놓고, 메서드를 추가하는방식으로 구현을했다고 가정해보자. 그럼에도 다음과 같은 문제가 발생한다.
     + 하위클래스에서 메서드 시그니쳐는 같지만, 반환형이 다를 경우 컴파일 오류가 생긴다.
        ``` java
        class Super{
            public void testA(int a){
                System.out.println(a);
            }
        }
       
       class Sub extends Super{
            public int testA(int a) { return a;} //새로 추가된 메서드, 반환형이 상위 클래스와 다르다. 컴파일오류
            public int testB(int b) { return b;}
       }
        ```
     + 반환타입이 같게된다면? 위에서의 두문제와 동일한문제가 발생한다. (새 메서드를 재정의한 것이기 때문)
     + 그렇기 때문에 확실하게 is - a 관계가 아니라면 사용을 금해야한다.

+ 그렇기 때문에, 컴포지션을 사용해야한다.
  + 기존의 클래스의 인스턴스를 private으로 참조하게하는 컴포지션을 사용하면된다.
  + 새롭게 만들어진 클래스의 인스턴스메서드들은, 참조하는 인스턴스의 메서드를 호출해서 사용하도록한다.
    + 이렇게할 경우, 기존 클래스의 구현방식의 영향에서 벗어날 수있다.
    + 새로운 클래스가 추가되더라도, 영향을 받지않는다.