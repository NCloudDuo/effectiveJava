# 적시에 방어적 복사본을 만들라

### 자바가 안전한 언어긴 하지만, 다른 클래스로부터의 침범을 아무런 노력없이 다 막을 수 있는건 아니니, 방어적으로 프로그래밍 해야한다.

### 가변인 낡은 값 타입을 이용하는 메서드일경우, 메서드를 오동작하게 만들 수 있다.

### 외부 공격으로부터 인스턴스의 내부를 보호하기 위해서는, 생성자에서 가변 매개변수 각각을 방어적 복사해야한다.
+ 그 후, 인스턴스안에서는 매개변수 원본이아닌 복사본을 사용해야한다.
+ 추가적으로, 매개변수의 유효성을 검사하기전에, 복사가 먼저행해져야한다.
  + 멀티스레딩 환경이라면 원본 객체의 유효성을 검사한 후 복사본을 만드는 그 찰나의 취약한 순간에 다른 스레드가 원본 객체를 수정할 위험이 있기 때문이다.
+ 매개변수를 복사할때도 clone을 사용해서 안되는 경우가 있다.
  + 매개변수가 제 3자에 의해 확장될 수 있는 타입이라면, clone이 악의를 가진 하위 클래스의 인스턴스를 반환할 수도있다.
+ getter를 통해서 내부 가변정보를 드러내는 경우도 복사본을 반환해야한다.

### 메서드든 생성자든 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때면, 항시 그 객체가 클래스에 넘겨진 뒤 임의로 변경되어도 그 클래스가 문제없이 동작할지를 따져보라.
+ 확신할 수 없다면, 복사본을 만들어 저장해야한다.

### 마찬가지로, 내부 객체를 클라이언트에 건네주기 전에 방어적 복사본을 만드는 것을 고려해봐야한다.

## 이 아이템에서 주로 강조하고 있는것은, 불변 객체들을 조합해 객체를 구성해야 방어적 복사를 할 일이 줄어든다.
+ List.of, unmodifiMap등의 불변객체를 반환하는것을 사용하는것이 좋을듯하다.
+ 잠깐 kotlin 얘기를 하자면, 아예 list, mutablelist와 같이 불변, 가변을 나눠놨음
  + java에서 List.of로 만들어지는 것은 ImmutableCollections인데, add가 컴파일이 가능하다.
    + UnsupportedOperationException이 발생
  + kotlin에서 List는 add 메서드가 존재하지도 않음